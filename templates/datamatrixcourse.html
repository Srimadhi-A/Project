<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Manipulation and Cleaning</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- study space in navbar -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jersey+15&display=swap" rel="stylesheet">
    <!--full font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Jersey+15&family=Philosopher:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dmcourse.css') }}">
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg">
        <div class="container">
            <a class="navbar-brand">Study Space</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('home') }}">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('home') }}#about">About</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('courses') }}">Courses</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('contact') }}">Contact</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('game') }}">MindZone</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('profile') }}">Profile</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <header>
        <!-- unit1 -->
<div id="unit1" class="unit active">
    <div class="container">
        <h1>Data Matrix Fundamentals</h1>
        <p>Understand the core concepts and applications of data matrices in data science and machine learning.</p>
        <h2>Course Overview</h2>
        <p>This module introduces you to the fundamental concepts of data matrices, which are essential for organizing, processing, and analyzing large datasets in various fields such as machine learning, image processing, and scientific computing.</p>
        <p>Each unit will walk you through different aspects of data matrices, including their structure, operations, and applications in real-world scenarios.</p>

        <h1>Unit 1: Introduction to Data Matrices</h1>
        <h2>What are Data Matrices?</h2>
        <p>Data matrices are two-dimensional structures used to organize and store data in rows and columns. They are commonly used in mathematical computations, data analysis, and machine learning tasks to represent datasets, where rows represent data points and columns represent features or attributes.</p>
        <p>Understanding how to work with data matrices is crucial for efficient data manipulation, analysis, and modeling.</p>

        <h3>Why are Data Matrices Important?</h3>
        <p>Data matrices are crucial for several reasons:</p>
        <ul>
            <li>They provide an efficient way to store large datasets in a structured format.</li>
            <li>They are the foundation for many mathematical operations, such as matrix multiplication, inversion, and transformations.</li>
            <li>They enable the representation of data for machine learning models, especially in supervised learning (e.g., regression, classification).</li>
            <li>They are used in fields like computer vision, natural language processing, and scientific computing.</li>
        </ul>

        <h3>Key Operations on Data Matrices</h3>
        <p>Here are some of the key operations you can perform on data matrices:</p>
        <ol>
            <li><strong>Matrix Addition:</strong> Adding two matrices of the same dimensions by adding their corresponding elements.</li>
            <li><strong>Matrix Multiplication:</strong> Multiplying two matrices, where the number of columns in the first matrix must match the number of rows in the second matrix.</li>
            <li><strong>Matrix Transposition:</strong> Flipping a matrix over its diagonal, switching the row and column indices.</li>
            <li><strong>Matrix Inversion:</strong> Finding the inverse of a matrix, which is essential for solving linear systems of equations.</li>
            <li><strong>Scalar Multiplication:</strong> Multiplying every element of the matrix by a constant scalar value.</li>
        </ol>

        <h3>Data Matrix Representation</h3>
        <p>A data matrix is typically represented as a 2D array or table, where each row corresponds to an individual data point, and each column represents a different feature or variable.</p>
        <ul>
            <li><strong>Rows:</strong> Each row represents an individual data point or observation.</li>
            <li><strong>Columns:</strong> Each column represents a specific feature or attribute of the data points.</li>
        </ul>

        <h3>Applications of Data Matrices</h3>
        <p>Data matrices are widely used in various fields:</p>
        <ul>
            <li><strong>Machine Learning:</strong> Data matrices are used to represent datasets in machine learning models, where rows are input features and columns are target variables.</li>
            <li><strong>Image Processing:</strong> Images can be represented as data matrices, where each pixel's value corresponds to an element in the matrix.</li>
            <li><strong>Scientific Computing:</strong> In scientific research, matrices are used to solve linear systems and perform numerical simulations.</li>
        </ul>

        <h3>Matrix Example</h3>
        <p>Here is an example of a data matrix before and after an operation:</p>
        <pre>
Before (Matrix A):
1  2  3
4  5  6
7  8  9

After Transposition (Matrix A^T):
1  4  7
2  5  8
3  6  9
        </pre>

        <h3>Matrix Notations</h3>
        <p>Matrix notation is used to represent the values within a matrix:</p>
        <ul>
            <li><strong>Matrix A:</strong> A = [[a₁₁, a₁₂], [a₂₁, a₂₂]] represents a 2x2 matrix.</li>
            <li><strong>Matrix X:</strong> X = [[x₁, x₂, x₃], [x₄, x₅, x₆]] represents a 2x3 matrix.</li>
        </ul>
    </div>
    <button onclick="showNext('unit1', 'unit2')">Mark as Done</button>
</div>
<!-- unit2 -->
<div id="unit2" class="unit">
    <h1>Unit 2: Understanding Data Structures in Programming</h1>
    <h2>Introduction to Data Structures</h2>
    <p>In programming, data structures are essential for organizing and managing data efficiently. This unit focuses on understanding the fundamental data structures used in computer science, their types, and when to use them.</p>

    <h3>Types of Data Structures</h3>
    <p>Data structures can be categorized based on their implementation and usage. Some of the most common types include:</p>

    <ul>
        <li><strong>Arrays:</strong> A collection of elements identified by index or key. Arrays are useful for storing a fixed-size sequence of elements.</li>
        <li><strong>Linked Lists:</strong> A linear collection of elements where each element points to the next, making it easier to add or remove elements.</li>
        <li><strong>Stacks:</strong> A collection of elements that follows the Last In, First Out (LIFO) principle. Useful for reversing actions or managing function calls.</li>
        <li><strong>Queues:</strong> A collection of elements that follows the First In, First Out (FIFO) principle. Useful for scheduling tasks.</li>
        <li><strong>Hash Tables:</strong> A structure that maps keys to values for efficient lookup. It’s ideal for fast data retrieval based on unique keys.</li>
        <li><strong>Graphs:</strong> A set of nodes connected by edges. Graphs are used for representing networks such as social networks, maps, or dependencies.</li>
        <li><strong>Heaps:</strong> A special tree-based structure used to implement priority queues, allowing for efficient retrieval of the largest or smallest element.</li>
    </ul>

    <h3>Why Data Structures Are Important?</h3>
    <p>Choosing the right data structure has a significant impact on the efficiency and performance of a program. Some key reasons data structures are important:</p>
    <ul>
        <li>They provide efficient storage and retrieval of data.</li>
        <li>They enable faster execution of algorithms by optimizing access time.</li>
        <li>They help in solving complex problems like network routing, dynamic programming, etc.</li>
        <li>They reduce time complexity and improve scalability in large systems.</li>
    </ul>

    <h3>Handling Incomplete or Missing Data in Data Structures</h3>
    <p>When working with data structures, you might encounter incomplete or missing data, especially in situations like data processing or database management. Here's how to handle such issues:</p>

    <ul>
        <li><strong>Null Values:</strong> Represent missing or undefined values in data structures. Many data structures like arrays, linked lists, and hash tables can store null values as placeholders.</li>
        <li><strong>Default Values:</strong> Use predefined default values (e.g., 0 for integers, empty string for text) to fill missing data in certain structures.</li>
        <li><strong>Lazy Initialization:</strong> Delaying the creation or modification of an element in a structure until it's actually needed, which helps in optimizing memory usage.</li>
        <li><strong>Segmentation:</strong> Split large data structures into smaller, more manageable segments to deal with missing or inconsistent data.</li>
        <li><strong>Imputation Techniques:</strong> For numerical data, techniques like interpolation can be used to estimate missing values based on nearby elements.</li>
    </ul>

    <h3>Example: Handling Missing Data in a Linked List</h3>
    <p>Consider a scenario where you have a linked list that holds user data, but some nodes might have missing or incomplete information. Here’s how you can handle that:</p>
    
    <h4>1. Using Default Nodes:</h4>
    <p>In the case of missing user information, you can create a default node with placeholder values, ensuring the list’s integrity remains intact.</p>

    <h4>2. Null Pointer Checks:</h4>
    <p>Always check for null pointers when traversing the linked list to avoid runtime errors due to missing data.</p>

    <h4>3. Imputation Using Neighboring Nodes:</h4>
    <p>When possible, use the information from neighboring nodes to infer or fill in missing data.</p>

    <h3>Choosing the Right Data Structure</h3>
    <p>Choosing the appropriate data structure depends on your use case. For example, if you need fast access to elements based on a key, a hash table is ideal. For scenarios involving frequent insertions and deletions, a linked list may be more appropriate. Always evaluate the operations your data structure needs to perform and the trade-offs of each structure before making a decision.</p>
    
    <button onclick="showNext('unit2', 'unit3')">Mark as Done</button>
</div>
<!-- unit 3 -->
<div id="unit3" class="unit">
    <h1>Unit 3: Understanding and Correcting Data Matrices</h1>

    <h2>Why Correct Data Matrices?</h2>
    <p>
        In data science and programming, incorrect data matrices can lead to inefficiencies, errors, and complex debugging. Choosing the right matrix for storing and processing data is crucial for optimized performance, especially in areas like machine learning, image processing, and scientific computations.
        <br><br>
        For instance, using a dense matrix when you have a sparse dataset can lead to inefficient memory usage. Similarly, choosing a matrix that doesn't suit the operations you need can result in slower computations. Properly structuring matrices ensures faster matrix operations, reduces memory usage, and makes algorithms more efficient.
    </p>

    <h3>Common Matrix Issues</h3>
    <ul>
        <li>Using dense matrices for sparse data, leading to inefficient memory usage</li>
        <li>Incorrect handling of matrix dimensions when performing matrix multiplication</li>
        <li>Choosing the wrong matrix type (e.g., identity matrix vs. diagonal matrix) for specific operations</li>
        <li>Unnecessary complex operations due to poor matrix structure choices</li>
        <li>Incorrect or inefficient matrix transformations due to suboptimal matrix selection</li>
    </ul>

    <h3>How to Correct Data Matrices</h3>
    <ol>
        <li>Use Dense Matrices for Complete Datasets</li>
        <pre>import numpy as np
dense_matrix = np.array([[1, 2, 3], [4, 5, 6]])  # Dense matrix for fully populated data</pre>

        <li>Use Sparse Matrices for Large, Mostly Empty Datasets</li>
        <pre>from scipy.sparse import csr_matrix
sparse_matrix = csr_matrix([[0, 0, 3], [4, 0, 0]])  # Sparse matrix for memory efficiency</pre>

        <li>Use Identity Matrix for Linear Algebra Operations</li>
        <pre>identity_matrix = np.identity(3)  # Identity matrix for linear transformations</pre>

        <li>Use Diagonal Matrices for Optimized Computation</li>
        <pre>diagonal_matrix = np.diag([1, 2, 3])  # Diagonal matrix for efficient calculations</pre>

        <li>Use Symmetric Matrices for Certain Mathematical Operations</li>
        <pre>symmetric_matrix = np.array([[1, 2], [2, 1]])  # Symmetric matrix for solving specific problems</pre>

        <li>Use Matrix Factorization for Missing Data</li>
        <pre>from sklearn.decomposition import NMF
model = NMF(n_components=2, init='random', random_state=0)
matrix_factorized = model.fit_transform(data_matrix)  # Use matrix factorization for missing values</pre>

        <li>Optimize Matrix Multiplication with the Right Algorithm</li>
        <pre>result_matrix = np.dot(matrix_a, matrix_b)  # Matrix multiplication using optimized algorithms</pre>

        <li>Use Matrix Transposition for Efficient Computations</li>
        <pre>transposed_matrix = matrix_a.T  # Transpose a matrix for various matrix operations</pre>

        <li>Use Matrix Decomposition Techniques (LU, QR, SVD)</li>
        <pre>U, S, Vt = np.linalg.svd(matrix)  # Singular Value Decomposition for matrix factorization</pre>

        <li>Use Efficient Matrix Search and Retrieval Techniques</li>
        <pre>index = np.where(matrix == target_value)  # Efficient search in a matrix</pre>
    </ol>

    <button onclick="showNext('unit3', 'unit4')">Mark as Done</button>
</div>
<div id="unit4" class="unit">
    <h1>Unit 4: Data Matrix Operations</h1>
    <h2>What is a Data Matrix?</h2>
    <p>A Data Matrix is a 2D array or table of values, often used in mathematics, computer science, and data analysis. It represents structured data in a grid format, where each element can be accessed using two indices, representing rows and columns.</p>

    <h3>Why are Data Matrices Important?</h3>
    <p>Data Matrices are essential in various fields such as machine learning, linear algebra, and data analysis. They allow us to represent complex data sets in a structured way, making it easier to perform operations like transformations, calculations, and manipulations.</p>

    <h4>Applications of Data Matrices</h4>
    <ul>
        <li><strong>Machine Learning:</strong> Data matrices are used to represent features and observations in machine learning models.</li>
        <li><strong>Computer Graphics:</strong> Data matrices are used in image transformations, rotations, and scaling operations.</li>
        <li><strong>Optimization Problems:</strong> They are used in optimization algorithms, such as linear programming, to represent coefficients and constraints.</li>
        <li><strong>Data Analysis:</strong> In statistical analysis, data matrices allow the representation of multiple variables and observations in a single, concise format.</li>
    </ul>

    <h3>Basic Matrix Operations</h3>
    <p>There are several fundamental operations that can be performed on matrices, such as:</p>

    <h4>1. Matrix Addition</h4>
    <p>Matrix addition is performed by adding the corresponding elements of two matrices of the same dimension.</p>
    <pre><code>
# Python: Matrix addition
import numpy as np
matrix_a = np.array([[1, 2], [3, 4]])
matrix_b = np.array([[5, 6], [7, 8]])
result = matrix_a + matrix_b
print(result)
    </code></pre>

    <h4>2. Matrix Multiplication</h4>
    <p>Matrix multiplication involves multiplying corresponding rows and columns from two matrices. The number of columns in the first matrix must equal the number of rows in the second matrix.</p>
    <pre><code>
# Python: Matrix multiplication
matrix_a = np.array([[1, 2], [3, 4]])
matrix_b = np.array([[5, 6], [7, 8]])
result = np.dot(matrix_a, matrix_b)
print(result)
    </code></pre>

    <h4>3. Matrix Transposition</h4>
    <p>The transpose of a matrix is obtained by swapping its rows with columns.</p>
    <pre><code>
# Python: Matrix transposition
matrix_a = np.array([[1, 2], [3, 4]])
transposed_matrix = matrix_a.T
print(transposed_matrix)
    </code></pre>

    <h4>4. Matrix Inversion</h4>
    <p>The inverse of a matrix is used to solve systems of linear equations. A matrix is invertible only if it is square and its determinant is non-zero.</p>
    <pre><code>
# Python: Matrix inversion
matrix_a = np.array([[1, 2], [3, 4]])
inverse_matrix = np.linalg.inv(matrix_a)
print(inverse_matrix)
    </code></pre>

    <h3>Working with Data Matrices in JavaScript</h3>
    <p>JavaScript can also be used to manipulate matrices using arrays of arrays. Here's how to perform basic matrix operations:</p>

    <h4>Matrix Addition in JavaScript</h4>
    <pre><code>
let matrixA = [
    [1, 2],
    [3, 4]
];
let matrixB = [
    [5, 6],
    [7, 8]
];
let result = matrixA.map((row, i) => row.map((val, j) => val + matrixB[i][j]));
console.log(result);
    </code></pre>

    <h4>Matrix Multiplication in JavaScript</h4>
    <pre><code>
let matrixA = [
    [1, 2],
    [3, 4]
];
let matrixB = [
    [5, 6],
    [7, 8]
];
let result = matrixA.map((row, i) => matrixB[0].map((_, j) => row.reduce((sum, el, k) => sum + el * matrixB[k][j], 0)));
console.log(result);
    </code></pre>

    <h3>Matrix Representation in Data Science</h3>
    <p>In data science, matrices are used to represent datasets, especially when dealing with large datasets for machine learning or statistical analysis. Libraries like NumPy in Python or math.js in JavaScript provide efficient ways to perform matrix operations.</p>

    <h3>Best Practices for Working with Data Matrices</h3>
    <ul>
        <li><strong>Understand Matrix Dimensions:</strong> Always ensure that matrices have compatible dimensions for operations like multiplication or addition.</li>
        <li><strong>Use Efficient Libraries:</strong> Utilize optimized libraries such as NumPy for Python or math.js for JavaScript to handle large matrices efficiently.</li>
        <li><strong>Avoid Redundant Operations:</strong> Be mindful of the computational cost of matrix operations and avoid redundant calculations.</li>
    </ul>

    <h3>Visualizing Matrices</h3>
    <p>To better understand and debug matrix operations, it can be helpful to visualize the matrix as a grid or image. In Python, you can use libraries like matplotlib to visualize matrices:</p>
    <pre><code>
# Python: Visualize matrix as heatmap
import matplotlib.pyplot as plt
import numpy as np
matrix = np.array([[1, 2], [3, 4]])
plt.imshow(matrix, cmap='hot', interpolation='nearest')
plt.colorbar()
plt.show()
    </code></pre>

    <h3>Real-World Applications of Data Matrices</h3>
    <ul>
        <li><strong>Machine Learning:</strong> Representing features and observations as matrices for algorithms like linear regression and neural networks.</li>
        <li><strong>Image Processing:</strong> Images are represented as matrices of pixel values, and operations like filtering and transformation are matrix-based.</li>
        <li><strong>Recommendation Systems:</strong> Matrices are used to represent user-item interactions and apply collaborative filtering techniques.</li>
        <li><strong>Scientific Computation:</strong> In scientific simulations and analyses, matrices are used for solving systems of equations and representing data.</li>
    </ul>

    <button onclick="showNext('unit4', 'unit5')">Mark as Done</button>
</div>
<div id="unit5" class="unit">
    <h1>Unit 5: Working with Data Matrices in Digital Marketing</h1>
    <p>Learn how to use data matrices for efficient representation and analysis of marketing data, helping you better manage campaigns and track performance.</p>

    <h2>What is a Data Matrix in Digital Marketing?</h2>
    <p>A data matrix in digital marketing refers to a two-dimensional array or table that organizes key marketing metrics like impressions, clicks, conversions, and ROI. These matrices allow for efficient analysis and comparison across different campaigns, platforms, and time periods.</p>

    <h3>Key Concepts in Marketing Data Matrices</h3>
    <ul>
        <li><strong>Matrix Representation of Campaign Data</strong>: Using rows for campaigns and columns for metrics (e.g., impressions, clicks, conversions), a data matrix allows for easy cross-referencing and quick insights.</li>
        <li><strong>Dynamic Metrics Handling</strong>: A data matrix can store dynamic data like spend, conversion rate, and engagement metrics across different marketing channels, enabling fast updates and comprehensive analysis.</li>
        <li><strong>Time-Series Data</strong>: Data matrices can store time-series data, allowing you to track and visualize trends in marketing performance over time.</li>
        <li><strong>Multi-Dimensional Analysis</strong>: You can extend data matrices to multi-dimensional data, such as adding more layers like customer segments or ad formats to gain a deeper understanding of campaign effectiveness.</li>
    </ul>

    <h3>Why Use Data Matrices for Marketing Data?</h3>
    <p>Data matrices offer several advantages when dealing with large marketing datasets:</p>
    <ul>
        <li><strong>Efficient Data Representation</strong>: A matrix format makes it easier to store and manage large datasets, making it quick to analyze performance and make decisions.</li>
        <li><strong>Flexible Data Processing</strong>: With a data matrix, you can easily perform operations like filtering, grouping, and aggregation, which is essential for in-depth analysis.</li>
        <li><strong>Visual Analysis</strong>: Data matrices can be easily visualized using tools like heatmaps or pivot tables, helping marketers quickly spot trends and anomalies.</li>
        <li><strong>Facilitating Predictive Analysis</strong>: With structured data, machine learning models can be applied more effectively for predictive analysis, helping forecast campaign performance.</li>
    </ul>

    <h3>Methods for Creating and Using Data Matrices in Digital Marketing</h3>
    <ul>
        <li><strong>Creating a Simple Data Matrix</strong>: You can create a data matrix to store campaign metrics such as clicks, impressions, and conversions for each campaign.</li>
<pre>
# Example using Python to create a basic data matrix for marketing campaigns
import pandas as pd

data = {
    'Campaign': ['Campaign1', 'Campaign2', 'Campaign3'],
    'Impressions': [1000, 1500, 1200],
    'Clicks': [50, 75, 60],
    'Conversions': [10, 20, 15]
}

df = pd.DataFrame(data)
print(df)
</pre>
        <li><strong>Advanced Matrix Operations</strong>: Perform operations like calculating conversion rates, ROI, or segment performance using data matrices.</li>
<pre>
# Example of calculating conversion rate using a data matrix
df['Conversion Rate'] = df['Conversions'] / df['Clicks'] * 100
print(df)
</pre>
        <li><strong>Filtering Data</strong>: Use conditions to filter data from the matrix for specific campaigns or platforms to focus on high-priority items.</li>
<pre>
# Example of filtering campaigns with high impressions
high_impression_campaigns = df[df['Impressions'] > 1200]
print(high_impression_campaigns)
</pre>
        <li><strong>Pivoting Data for Cross-Platform Analysis</strong>: Use pivot tables to aggregate and analyze data across different platforms or time periods.</li>
<pre>
# Example of pivoting campaign data for platform comparison
pivot_data = df.pivot(index='Campaign', columns='Platform', values='Conversions')
print(pivot_data)
</pre>
    </ul>

    <h3>Advanced Techniques with Data Matrices</h3>
    <ul>
        <li><strong>Heatmaps for Performance Visualization</strong>: Visualize a data matrix using heatmaps to spot trends and patterns in performance across different metrics.</li>
<pre>
# Example of creating a heatmap for data matrix visualization
import seaborn as sns
import matplotlib.pyplot as plt

sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.show()
</pre>
        <li><strong>Multi-Dimensional Data Matrices</strong>: Expand your matrix to include more dimensions, like customer segmentation, to analyze how different segments respond to campaigns.</li>
<pre>
# Example of adding a segmentation dimension
df['Customer Segment'] = ['Segment1', 'Segment2', 'Segment3']
print(df)
</pre>
    </ul>

    <h3>Challenges in Working with Data Matrices</h3>
    <ul>
        <li><strong>Handling Missing Data</strong>: Marketing data matrices may contain missing or incomplete data, requiring techniques like imputation or dropping missing values.</li>
        <li><strong>Scalability</strong>: Large datasets can make matrix operations computationally expensive, requiring optimization techniques or distributed computing solutions.</li>
        <li><strong>Data Consistency</strong>: Maintaining data consistency across multiple marketing channels can be challenging, especially when dealing with dynamic campaign data.</li>
    </ul>

    <h3>Practical Example: Analyzing Campaigns Using a Data Matrix</h3>
<pre>
# Sample data for analyzing campaigns performance
campaign_data = {
    'Campaign': ['Summer Sale', 'Winter Sale', 'Black Friday'],
    'Impressions': [10000, 12000, 15000],
    'Clicks': [800, 1000, 1500],
    'Conversions': [100, 150, 200]
}

df_campaigns = pd.DataFrame(campaign_data)

# Calculating metrics such as Click-Through Rate (CTR) and Conversion Rate (CR)
df_campaigns['CTR'] = df_campaigns['Clicks'] / df_campaigns['Impressions'] * 100
df_campaigns['Conversion Rate'] = df_campaigns['Conversions'] / df_campaigns['Clicks'] * 100

print(df_campaigns)
</pre>

    <h3>Real-World Applications</h3>
    <ul>
        <li><strong>Campaign Performance Dashboards</strong>: Use data matrices to visualize campaign performance across different metrics, platforms, and time periods in real-time.</li>
        <li><strong>Audience Segmentation</strong>: Analyze customer behavior by segmenting data in the matrix to target specific groups more effectively.</li>
        <li><strong>Cross-Platform Analytics</strong>: Compare performance across various marketing platforms using data matrices to evaluate ROI and optimize campaigns.</li>
        <li><strong>Budget Allocation</strong>: Use data matrices to determine the most effective channels for budget allocation based on historical performance.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Data matrices are an essential tool in digital marketing for organizing, analyzing, and visualizing complex datasets. They provide a structured format that makes it easier to compare, track, and optimize marketing campaigns, leading to better insights and more effective strategies.</p>

    <b><h1>🎉 Congratulations! You’ve completed the unit on Working with Data Matrices in Digital Marketing.</h1></b>
    <button><a href="{{url_for('theoryquiz')}}">Start Quiz</a></button>
</div>
</body>
<script>

    function showNext(currentId, nextId) {
        document.getElementById(currentId).classList.remove('active');
        document.getElementById(nextId).classList.add('active');
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    }

</script>


</html>